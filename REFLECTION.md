# Reflection
   
### Path planning workflow.
The path planning code consists of the following steps
1. Analyze surrounding cars' locations.
2. Determine path planning strategy.
3. Generate path curve (continuous).
4. Generate car path (discrete) for control.

### Step 1: Analyze surrounding cars' locations
In this step, all surrounding cars' locations relative to the ego car are analyzed. The analysis result will tell ego car whether a surrounding car is nearby right ahead, on the left lane, or on the right lane. Based on these facts, path planning strategy will be made in next step.

### Step 2: Determine path planning strategy
Based on the facts found in the previous step, the path planning strategy will be made, which is:
1. If there is another car nearby right ahead of ego car, then:
    1) try to move to left lane if traffic is clear. Otherwise, move to right lane if traffic is clear.
    2) if lane change is impossible, slow down ego car to avoid collision.
2. If there is no other cars nearby the ego car, then:
    1) drive ego car back to center lane if possible, giving it the flexibility to change to both left and right lane in case traffic becomes heavy down the road.
    2) in the meantime, speed up the ego car but ensure it runs below speed limit.
3. In the code, the maximum speed change is set to 0.1 m/s in each 0.02 second window (MAX_ACC = 0.1), which is equivalent to 5 m/s^2. The speed limit is set to 49.8 mph, which is equivalent to 22.26 m/s (MAX_SPEED = 49.8 * 0.44704).
    
### Step 3: Generate path curve (continuous)
Once the strategy is made, a continuous path curve is draw with spline using a few key way points, including:
1. If there is enough way points from previous path, use USE_N_PREV_WPS of them and then add another 3 down the road with the x coordinate at 1 * PREDICT_HORIZON_IN_DIST, 2 * PREDICT_HORIZON_IN_DIST and 3 * PREDICT_HORIZON_IN_DIST, with y at desired ego car lane. If a lane change is expected, these y coordinates will reflect that.
2. If there is no enough way points from previous path, just use the current coordinates of ego car, and add another 3 down the road, which are generated the same way as in previous step. Using way points from previous path will ensure smoothness of the new path.
3. In the code, 2 way points are used from previous path (USE_N_PREV_WPS = 2). Prediction horizon is set to 30 meters (PREDICT_HORIZON_IN_DIST=30). All calculations are done in metric units.

### Step 4: Generate car path (discrete) for control
Based on the path curve acquired in previous step, the discrete path will be generated consisting the following steps:
1. First generate discrete way points in ego car's coordinate system, assuming a travel time of 0.02 seconds between 2 successive way points. During the process, x coordinates are generated by projecting ego car's desired speed forward. y coordinates are computed by the continuous path curve function.
2. Then, translate all discrete way points back into global coordinate system.
3. In the last, send generated discrete way points to control.
4. In the code, a total of (50-2)=48 new way points are generated in each cycle, and 2 previous way points are used (GEN_N_WPS = 50, USE_N_PREV_WPS = 2).

### Other reflections
I tried the PTG approach in the beginning. However, in the JMT step, the estimation of end states becomes critical to the smoothness/comfortness of the path. A bad estimation of end states will give a smooth curve on paper but not necessarily smooth accelerations when the ego car is driven along the path. Therefore the key step is actually not the PTG path generation, but end state estimation. However, if we are able to do a good estimation on the end state of the ego car at each cycle, we can directly control its speed or lane change rather than generating another curve to do it. Therefore, I eventually did not adopt the PTG approach, but used the simpler spline curve approach instead.